\chapter{Related Work}

We now look at some related efforts in terms of Plan Recognition and parallelisation. Various Approaches to probabilistic Plan Recognition based on Hidden Markov Models (HMMs) and Conditional Random Fields (CRFs) exist. The AHMM model\cite{bib:hmm} allows online, probabilistic Plan Recognition, including a representation of the state of the world and its effect on the planning of agents; however, it does not deal with interleaved or partially-ordered plans.
Graph-based methods reduce plan recognition to a graph covering problem. The algorithm in \cite{bib:graph} is able to perform Plan Recognition lazily, computing explanations efficiently and only as needed, but it does not provide probabilities for the explanations, and does not deal with interleaved or partially-ordered plans.

There is extensive literature on parallelising search problems\cite{bib:search}, and some of this could be applicable to Plan Recognition algorithms. However, since ELEXIR performs an exhaustive rather than heuristic search, they are not directly applicable to this project. There has been some work on parallelising the parsing problem\cite{bib:parsing}, however this applies mainly to traditional parsing problems based on context-free grammars with no ambiguity, where only a single parse will result from a given input. These methods do not need to deal with contextual effects and multiple parse explanations. They are applicable to much larger inputs presented in batch form, such as program source millions of lines long. Parallelisation strategies are therefore quite different from the ones we consider, for example by starting simultaneous parses at multiple points in the input stream and combining the resulting partial parse trees.

Clark and Curran have developed a parallel implementation for learning of CCGs in Natural Language\cite{bib:ccgpar}, which runs in parallel and distributed fashion on a Beowulf cluster. However, the parsing aspect is not a complete parallel parser like the one we develop here.

The influential Cilk algorithm\cite{bib:workstealing} schedules strict computations with dependencies between tasks. This paper discusses the advantages of work-stealing over work-sharing algorithms, and gives bounds on the efficiency of work-stealing. Chase \& Lev describe an algorithm\cite{bib:queue} for a lock-free work-stealing queue, which we base ourselves on for our own implementation.
