\chapter{Evaluation}

An important stage in developing a user interface (especially one which is
designed to improve usability) is to evaluate the system with user testing.
There are three reasons for performing this task: to check whether the software
actually helped the users, by how much the users were helped and also to see
how the software could be changed in order to improve its usability.

\section{Methods Used}

\subsection{User Testing}

The users were given a set of tasks to complete (section~\ref{sec:tasks}) and
a database schema that they should use to perform these tasks
(section~\ref{sec:schema}). The list of tasks was chosen in order to use as
many of the features of the application as possible. These tasks were then
performed on two different database querying applications: one that required
the user to enter \ac{SQL} and my application for querying the database.

The users were then timed on how long they took to complete the task (whether
they completed the task successfully or not). The time that it took to complete
the task along with whether or not the user was successful in completing the
task was then recorded. If the user made a small mistake with the \ac{SQL}
syntax or made a graph that did not provide the exact result then this was also
marked as a failure. During the user working through the tasks notes were taken
about any problems that the users had using the application.

\subsection{Questionnaire}

After completing the tasks described above the users filled in a short
questionnaire about their experience using both tools and the comparison
between them. The final section of the questionnaire asked the user for
longer-form answers about how they thought the application could be improved
and any other comments they had about using the application.

\section{Results Analysis}

\subsection{Minimal Previous SQL Experience}

For users who were new to SQL the system allowed the to query a database
effectively but admittedly at a much slower pace than users who were able to
call upon their \ac{SQL} experience. The best example of this is \textbf{User
1} who had no knowledge of SQL and yet was still able to use the application.

However, it was noted that a user who did not have at least a basic level of
understanding of \ac{SQL} had some trouble working out some of the phrases used
in in the application.

\begin{description}

\item[Select vs. Filter] \hfill

Some users found the distinction between \textbf{select} and \textbf{filter} (a
WHERE clause in \ac{SQL}) to be, in their mind, synonymous and often confused
the two.

\item[Equal vs. Matches] \hfill

User 1 in particular found the difference between \textbf{eq} ($=$) and
\textbf{matches} to be confusing.

\end{description}

Obviously, the times that the users who did not know \ac{SQL} took to complete
the task are in this case not useful as there is nothing to compare them to.
However, User 2 provided interesting data as they had a basic understanding of
\ac{SQL}. The time differences between the two were either insignificant or it
was found that using \ac{SQL} to query the database was considerably faster.

Where I feel the most interesting results come is that in all but one case that
if a user wasn't able to complete the task \emph{correctly} when using SQL then
they were able to create a valid and correct query using the graph query
application. This may show that even though users were slower at creating
queries using the application the queries that they created were syntactically
and semantically correct.

\subsection{Previous SQL Experience}

The users with previous \ac{SQL} experience provided the most complete and
useful timing results as they were able to provide results for both the
\ac{SQL} and new application questions. However, similar to \textbf{User 2}
their times were also similar or slower using the graph query application
rather than using plain \ac{SQL}.

The problems that the more advanced users encountered were more with the
usability of the program rather than any confusion with the usage of the
program itself. However, all users apart from \textbf{User 3} had difficulty
when they were required to join 3 tables together. The users who knew \ac{SQL}
were also able to create the simple (2 table equi-join) joins easily.

\subsection{Questionnaire Answers}

The most promising results by far were those from the questionnaire. Every
single user preferred using the graph query application to using \ac{SQL}.
Additionally, all of the users stated that they would consider using the
application to perform queries in the future.

\section{Improvements to the Application}

After getting feedback from the user testing there are a number of things that
I could do to improve the usability of the application and allow users that are
not familiar with \ac{SQL} to more easily use the application.

\begin{description}

\item[Remove Joins] \hfill

The idea of joins was confusing for all users. The more advanced users were
able to figure them out after some slight thought. The beginner users had
significant trouble understanding how they worked and how to apply them to the
problem. Both sets of users had trouble joining more than 2 tables together.

To this end it may be wise to remove the concept of joins from the application
entirely and automatically enter them into the queries if they are
needed.\footnote{TODO: Possibly cite Sasa's project work this year?} When
a user selects data that is sourced from more than 1 table we would
automatically scan the database for the list of tables that could be joined
together in order to compute the join. However, at the current moment the
application doesn't have a connection open to the database while it is running
it would be up to the user to enter in the schema details in order for this to
be computed. Alternatively we could allow the application to connect to the
database to gather the schema for itself.

The next problem is working out how to join two tables together also without
requiring the user to enter extra information. Given two tables there are a few
ways that we could compute the correct join attributes.

\begin{itemize}

\item Check for explicit foreign key definitions in the database.

\item Check to see for matching data types in the two tables.

\item Check to see if there are any clues in the names of the attributes. For
	example, \texttt{student\_id} will probably join to an attribute named
	\texttt{id} in a table named \texttt{student}.

\item Check to see if the values in one column of one table are in the other
	column of the other table.

\item All of the above. By using a compound score and weighting all of the
	different metrics based on how reliable they were we would be able to take
	the pairing with the maximum score and use that.

\end{itemize}

\item[Select/Filter Confusion] \hfill

Due to the confusion between the \textbf{select} and \textbf{filter} nodes and
their purposes there should be work done into clarifying the two. This could be
as simple as finding better names for them or alternatively removing the
concept of column selection completely and allowing the user select the columns
that they would like to get when they place the output node.

\item[Moving \& Deleting placed nodes] \hfill

Many users attempted to either move or delete nodes after they had been placed.
This is an obvious fix and just requires adding those features to the
application. This should also stop any user confusion at messy graphs after
they have placed the nodes in the wrong location.

\item[Arrows] \hfill

To help the users understand the flow of data through the application it may be
useful for them to visualise this by adding arrows on to the edges between
nodes. This makes sense as the graph is technically directed.

\end{description}
